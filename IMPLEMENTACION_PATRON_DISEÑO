# ğŸ“˜ DocumentaciÃ³n de Cambios â€” Actividad 5  
**AplicaciÃ³n de Patrones de DiseÃ±o en Django (EafitTrade)**  

---

## ğŸ§© PatrÃ³n 2: Template Method Pattern  

### ğŸ“ Contexto  

En el proyecto **EafitTrade**, las vistas encargadas del CRUD de productos (`add_product`, `edit_product` y `delete_product`) contenÃ­an **lÃ³gica duplicada**:  
- ValidaciÃ³n de formularios  
- Mensajes al usuario  
- Redirecciones y manejo de errores  
- VerificaciÃ³n de permisos del vendedor  

Esto dificultaba la **mantenibilidad** del cÃ³digo y violaba el principio DRY (*Donâ€™t Repeat Yourself*).  

---

### ğŸ—ï¸ DecisiÃ³n de DiseÃ±o  

Se aplicÃ³ el **PatrÃ³n Template Method**, un patrÃ³n de comportamiento que permite definir **la estructura general de un algoritmo** en una clase base y dejar que las **subclases personalicen partes especÃ­ficas** del mismo.  

**Objetivo:**  
- Centralizar la lÃ³gica comÃºn del CRUD de productos.  
- Permitir que cada acciÃ³n (crear, editar, eliminar) personalice solo los pasos necesarios.  
- Facilitar la extensiÃ³n o modificaciÃ³n del flujo sin romper la estructura principal.  

---

### âš™ï¸ Cambios Realizados en el CÃ³digo  

#### ğŸ“ Nueva Estructura

products/
â”œâ”€â”€ views/
â”‚ â”œâ”€â”€ init.py
â”‚ â”œâ”€â”€ base_product_view.py # Clase base con Template Method
â”‚ â”œâ”€â”€ add_product_view.py # Subclase concreta (Create)
â”‚ â”œâ”€â”€ edit_product_view.py # Subclase concreta (Update)
â”‚ â”œâ”€â”€ delete_product_view.py # Subclase concreta (Delete)
â”‚ â””â”€â”€ ...
â””â”€â”€ ...


---

### ğŸ§± 1. Clase Base `BaseProductView`
ğŸ“„ **UbicaciÃ³n:** `products/views/base_product_view.py`

```python
from abc import ABC, abstractmethod
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from products.models import Product

class BaseProductView(ABC):
    template_name = None
    success_message = None
    error_message = None

    def dispatch(self, request, *args, **kwargs):
        """MÃ©todo plantilla: define el flujo general"""
        try:
            if request.method == 'POST':
                return self.handle_post(request, *args, **kwargs)
            return self.handle_get(request, *args, **kwargs)
        except Exception as e:
            messages.error(request, f"OcurriÃ³ un error: {str(e)}")
            return redirect('home')

    @abstractmethod
    def handle_get(self, request, *args, **kwargs):
        """Paso a personalizar: manejar solicitudes GET"""
        pass

    @abstractmethod
    def handle_post(self, request, *args, **kwargs):
        """Paso a personalizar: manejar solicitudes POST"""
        pass

### ğŸ§  Motivo:
Esta clase define el esqueleto del flujo CRUD: manejo de errores, verificaciÃ³n del mÃ©todo HTTP, y estructura general.
Cada subclase concreta solo implementa la parte que cambia (handle_get y handle_post).

### Clases implicadas:
Todas estas funcionalidades se guardaron en la carpeta de views_Patron_DiseÃ±o
-Subclase AddProductView
-Subclase EditProductView
-Subclase DeleteProductView

###ğŸ§© Ventajas Obtenidas

ReutilizaciÃ³n: La clase base gestiona errores, permisos y estructura.
Extensibilidad: Se pueden agregar nuevos tipos de acciones sin alterar las existentes.
Consistencia: Todas las operaciones CRUD siguen el mismo flujo.
Cumplimiento de SOLID:

S: Cada vista tiene una responsabilidad especÃ­fica.
O: Abierto a extensiÃ³n, cerrado a modificaciÃ³n.
L: Subclases reemplazan a la base sin alterar el flujo.