# 📘 Documentación de Cambios — Actividad 5  
**Aplicación de Patrones de Diseño en Django (EafitTrade)**  

---

# 🧩 Patrón 1: Template Method Pattern  

### 📍 Contexto  

En el proyecto **EafitTrade**, las vistas encargadas del CRUD de productos (`add_product`, `edit_product` y `delete_product`) contenían **lógica duplicada**:  
- Validación de formularios  
- Mensajes al usuario  
- Redirecciones y manejo de errores  
- Verificación de permisos del vendedor  

Esto dificultaba la **mantenibilidad** del código y violaba el principio DRY (*Don’t Repeat Yourself*).  

---

### 🏗️ Decisión de Diseño  

Se aplicó el **Patrón Template Method**, un patrón de comportamiento que permite definir **la estructura general de un algoritmo** en una clase base y dejar que las **subclases personalicen partes específicas** del mismo.  

**Objetivo:**  
- Centralizar la lógica común del CRUD de productos.  
- Permitir que cada acción (crear, editar, eliminar) personalice solo los pasos necesarios.  
- Facilitar la extensión o modificación del flujo sin romper la estructura principal.  

---

### ⚙️ Cambios Realizados en el Código  

#### 📁 Nueva Estructura

products/
├── views/
│ ├── init.py
│ ├── base_product_view.py # Clase base con Template Method
│ ├── add_product_view.py # Subclase concreta (Create)
│ ├── edit_product_view.py # Subclase concreta (Update)
│ ├── delete_product_view.py # Subclase concreta (Delete)
│ └── ...
└── ...


---

### 🧱 1. Clase Base `BaseProductView`
📄 **Ubicación:** `products/views/base_product_view.py`

```python
from abc import ABC, abstractmethod
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from products.models import Product

class BaseProductView(ABC):
    template_name = None
    success_message = None
    error_message = None

    def dispatch(self, request, *args, **kwargs):
        """Método plantilla: define el flujo general"""
        try:
            if request.method == 'POST':
                return self.handle_post(request, *args, **kwargs)
            return self.handle_get(request, *args, **kwargs)
        except Exception as e:
            messages.error(request, f"Ocurrió un error: {str(e)}")
            return redirect('home')

    @abstractmethod
    def handle_get(self, request, *args, **kwargs):
        """Paso a personalizar: manejar solicitudes GET"""
        pass

    @abstractmethod
    def handle_post(self, request, *args, **kwargs):
        """Paso a personalizar: manejar solicitudes POST"""
        pass

### 🧠 Motivo:
Esta clase define el esqueleto del flujo CRUD: manejo de errores, verificación del método HTTP, y estructura general.
Cada subclase concreta solo implementa la parte que cambia (handle_get y handle_post).

### Clases implicadas:
Todas estas funcionalidades se guardaron en la carpeta de views_Patron_Diseño
-Subclase AddProductView
-Subclase EditProductView
-Subclase DeleteProductView

###🧩 Ventajas Obtenidas

Reutilización: La clase base gestiona errores, permisos y estructura.
Extensibilidad: Se pueden agregar nuevos tipos de acciones sin alterar las existentes.
Consistencia: Todas las operaciones CRUD siguen el mismo flujo.
Cumplimiento de SOLID:

S: Cada vista tiene una responsabilidad específica.
O: Abierto a extensión, cerrado a modificación.
L: Subclases reemplazan a la base sin alterar el flujo.



# 🧩 Patrón 2: Normalización de modelos en la aplicación products

1️⃣ Objetivo

Optimizar la estructura del modelo Product mediante la normalización de las entidades dependientes (Category, Condition y FoodType), aplicando buenas prácticas de modelado relacional para mejorar la consistencia, escalabilidad y mantenibilidad de la base de datos en el sistema EafitTrade


2️⃣ Contexto del cambio

Inicialmente, el modelo Product utilizaba listas de opciones estáticas (choices) para las categorías, condiciones y tipos de comida.
Si bien esto era funcional, presentaba limitaciones:

Dificultaba la modificación dinámica de categorías o condiciones sin alterar el código.

Impedía la administración flexible desde el panel de Django Admin.

Limitaba las relaciones y consultas entre productos y sus tipos asociados.

Para resolverlo, se implementó una normalización de tablas:
ahora, cada una de estas entidades (Category, Condition, FoodType) se representa como un modelo independiente, relacionado con Product mediante una clave foránea (ForeignKey).


3️⃣ Implementación técnica
📂 Nueva estructura de modelos

Los modelos normalizados se ubican en:

products/
 ├── modelos_normalizados/
 │   ├── category.py
 │   ├── condition.py
 │   └── food_type.py
 └── models.py


🧩 Cambios aplicados en models.py

Se sustituyeron los campos de texto con choices por relaciones ForeignKey a las nuevas tablas normalizadas:

4️⃣ Ajustes de migraciones y base de datos

Debido a los cambios en la estructura, fue necesario reinicializar las migraciones y la base de datos para evitar conflictos con las antiguas columnas CharField.

5️⃣ Carga de datos iniciales

Para poblar las tablas normalizadas con los valores predefinidos, se usó el shell de Django:

from products.modelos_normalizados.food_type import FoodType

for tipo in [
    'Panadería', 'Galletas', 'Repostería', 'Frutas', 'Frituras',
    'Dulces', 'Helados', 'Snacks', 'Comida rápida', 'Otros'
]:
    FoodType.objects.get_or_create(name=tipo)


6️⃣ Resultados y beneficios

✅ Consistencia de datos:
Los valores repetidos o escritos incorrectamente ya no son posibles, pues provienen de registros controlados.

✅ Facilidad de administración:
Los administradores pueden agregar, editar o eliminar categorías desde el panel de Django Admin, sin modificar el código fuente.

✅ Escalabilidad:
Permite integrar nuevas entidades (por ejemplo, “Subcategorías” o “Tipos de condición”) mediante relaciones adicionales.


7️⃣ Conclusión

La normalización aplicada al modelo Product optimiza la arquitectura de datos del sistema, siguiendo principios de 3ª forma normal en bases relacionales.
Esto mejora la integridad referencial, reduce redundancia y permite una mayor flexibilidad de administración y mantenimiento en la aplicación.