# ğŸ“˜ DocumentaciÃ³n de Cambios â€” Actividad 5  
**AplicaciÃ³n de Patrones de DiseÃ±o en Django (EafitTrade)**  

---

# ğŸ§© PatrÃ³n 1: Template Method Pattern  

### ğŸ“ Contexto  

En el proyecto **EafitTrade**, las vistas encargadas del CRUD de productos (`add_product`, `edit_product` y `delete_product`) contenÃ­an **lÃ³gica duplicada**:  
- ValidaciÃ³n de formularios  
- Mensajes al usuario  
- Redirecciones y manejo de errores  
- VerificaciÃ³n de permisos del vendedor  

Esto dificultaba la **mantenibilidad** del cÃ³digo y violaba el principio DRY (*Donâ€™t Repeat Yourself*).  

---

### ğŸ—ï¸ DecisiÃ³n de DiseÃ±o  

Se aplicÃ³ el **PatrÃ³n Template Method**, un patrÃ³n de comportamiento que permite definir **la estructura general de un algoritmo** en una clase base y dejar que las **subclases personalicen partes especÃ­ficas** del mismo.  

**Objetivo:**  
- Centralizar la lÃ³gica comÃºn del CRUD de productos.  
- Permitir que cada acciÃ³n (crear, editar, eliminar) personalice solo los pasos necesarios.  
- Facilitar la extensiÃ³n o modificaciÃ³n del flujo sin romper la estructura principal.  

---

### âš™ï¸ Cambios Realizados en el CÃ³digo  

#### ğŸ“ Nueva Estructura

products/
â”œâ”€â”€ views/
â”‚ â”œâ”€â”€ init.py
â”‚ â”œâ”€â”€ base_product_view.py # Clase base con Template Method
â”‚ â”œâ”€â”€ add_product_view.py # Subclase concreta (Create)
â”‚ â”œâ”€â”€ edit_product_view.py # Subclase concreta (Update)
â”‚ â”œâ”€â”€ delete_product_view.py # Subclase concreta (Delete)
â”‚ â””â”€â”€ ...
â””â”€â”€ ...


---

### ğŸ§± 1. Clase Base `BaseProductView`
ğŸ“„ **UbicaciÃ³n:** `products/views/base_product_view.py`

```python
from abc import ABC, abstractmethod
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from products.models import Product

class BaseProductView(ABC):
    template_name = None
    success_message = None
    error_message = None

    def dispatch(self, request, *args, **kwargs):
        """MÃ©todo plantilla: define el flujo general"""
        try:
            if request.method == 'POST':
                return self.handle_post(request, *args, **kwargs)
            return self.handle_get(request, *args, **kwargs)
        except Exception as e:
            messages.error(request, f"OcurriÃ³ un error: {str(e)}")
            return redirect('home')

    @abstractmethod
    def handle_get(self, request, *args, **kwargs):
        """Paso a personalizar: manejar solicitudes GET"""
        pass

    @abstractmethod
    def handle_post(self, request, *args, **kwargs):
        """Paso a personalizar: manejar solicitudes POST"""
        pass

### ğŸ§  Motivo:
Esta clase define el esqueleto del flujo CRUD: manejo de errores, verificaciÃ³n del mÃ©todo HTTP, y estructura general.
Cada subclase concreta solo implementa la parte que cambia (handle_get y handle_post).

### Clases implicadas:
Todas estas funcionalidades se guardaron en la carpeta de views_Patron_DiseÃ±o
-Subclase AddProductView
-Subclase EditProductView
-Subclase DeleteProductView

###ğŸ§© Ventajas Obtenidas

ReutilizaciÃ³n: La clase base gestiona errores, permisos y estructura.
Extensibilidad: Se pueden agregar nuevos tipos de acciones sin alterar las existentes.
Consistencia: Todas las operaciones CRUD siguen el mismo flujo.
Cumplimiento de SOLID:

S: Cada vista tiene una responsabilidad especÃ­fica.
O: Abierto a extensiÃ³n, cerrado a modificaciÃ³n.
L: Subclases reemplazan a la base sin alterar el flujo.



# ğŸ§© PatrÃ³n 2: NormalizaciÃ³n de modelos en la aplicaciÃ³n products

1ï¸âƒ£ Objetivo

Optimizar la estructura del modelo Product mediante la normalizaciÃ³n de las entidades dependientes (Category, Condition y FoodType), aplicando buenas prÃ¡cticas de modelado relacional para mejorar la consistencia, escalabilidad y mantenibilidad de la base de datos en el sistema EafitTrade


2ï¸âƒ£ Contexto del cambio

Inicialmente, el modelo Product utilizaba listas de opciones estÃ¡ticas (choices) para las categorÃ­as, condiciones y tipos de comida.
Si bien esto era funcional, presentaba limitaciones:

Dificultaba la modificaciÃ³n dinÃ¡mica de categorÃ­as o condiciones sin alterar el cÃ³digo.

ImpedÃ­a la administraciÃ³n flexible desde el panel de Django Admin.

Limitaba las relaciones y consultas entre productos y sus tipos asociados.

Para resolverlo, se implementÃ³ una normalizaciÃ³n de tablas:
ahora, cada una de estas entidades (Category, Condition, FoodType) se representa como un modelo independiente, relacionado con Product mediante una clave forÃ¡nea (ForeignKey).


3ï¸âƒ£ ImplementaciÃ³n tÃ©cnica
ğŸ“‚ Nueva estructura de modelos

Los modelos normalizados se ubican en:

products/
 â”œâ”€â”€ modelos_normalizados/
 â”‚   â”œâ”€â”€ category.py
 â”‚   â”œâ”€â”€ condition.py
 â”‚   â””â”€â”€ food_type.py
 â””â”€â”€ models.py


ğŸ§© Cambios aplicados en models.py

Se sustituyeron los campos de texto con choices por relaciones ForeignKey a las nuevas tablas normalizadas:

4ï¸âƒ£ Ajustes de migraciones y base de datos

Debido a los cambios en la estructura, fue necesario reinicializar las migraciones y la base de datos para evitar conflictos con las antiguas columnas CharField.

5ï¸âƒ£ Carga de datos iniciales

Para poblar las tablas normalizadas con los valores predefinidos, se usÃ³ el shell de Django:

from products.modelos_normalizados.food_type import FoodType

for tipo in [
    'PanaderÃ­a', 'Galletas', 'ReposterÃ­a', 'Frutas', 'Frituras',
    'Dulces', 'Helados', 'Snacks', 'Comida rÃ¡pida', 'Otros'
]:
    FoodType.objects.get_or_create(name=tipo)


6ï¸âƒ£ Resultados y beneficios

âœ… Consistencia de datos:
Los valores repetidos o escritos incorrectamente ya no son posibles, pues provienen de registros controlados.

âœ… Facilidad de administraciÃ³n:
Los administradores pueden agregar, editar o eliminar categorÃ­as desde el panel de Django Admin, sin modificar el cÃ³digo fuente.

âœ… Escalabilidad:
Permite integrar nuevas entidades (por ejemplo, â€œSubcategorÃ­asâ€ o â€œTipos de condiciÃ³nâ€) mediante relaciones adicionales.


7ï¸âƒ£ ConclusiÃ³n

La normalizaciÃ³n aplicada al modelo Product optimiza la arquitectura de datos del sistema, siguiendo principios de 3Âª forma normal en bases relacionales.
Esto mejora la integridad referencial, reduce redundancia y permite una mayor flexibilidad de administraciÃ³n y mantenimiento en la aplicaciÃ³n.